---
authors: Robert Mustacchi <rm@joyent.com>
state: predraft
---

<!--
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
-->

<!--
    Copyright (c) 2017, Joyent, Inc. 
-->


# RFD 97 Project Hookshot - Improved VLAN Handling

VLANs are a predominant and commonly used aspect of networking. However,
the illumos networking stack does not often behave as well in the face
of VLANs. Many of the behaviors and enhancements in the networking stack
that are used do not apply to VLANs. However, we find that most of our
customers, and even our own deployments, are almost exclusively filled
with networks that are based on VLANs. In part, this is due to the ease
of the creation of devices on a VLAN either through `dladm create-vlan`
or `dladm create-vnic -v`.

## VLAN Refresher

Before, we delve too deeply, it's worth going over a brief refresher of
what a VLAN is and why it's used. An Ethernet packet has a field called
an Ethertype. This Ethertype is a 16-bit identifier which is used to
indicate the type of packet that is being used. For example, 0x800
indicates an IPv4 packet, 0x806 indicates an ARP packet, and 0x86dd
indicates an IPv6 packet. The following is the breakdown of a typical
packet.

```
+-----------------+-----------+------------+------+
| Ethernet Header | IP Header | TCP Header | Data |
+-----------------+-----------+------------+------+
```

If we break down the Ethernet header, it then looks like:

```
+-------------+---------------+-----------+------+
| 6-byte Dest | 6-byte Source | 2-byte    | Data |
| MAC Address | Mac Address   | Ethertype |      |
+-------------+---------------+-----------+------+
```

VLAN tagged packets are indicated with an Ethertype of 0x8100. When
a VLAN tagged packet is encountered, it indicates that the packet uses a
modified Ethernet header. Following the Ethertype indicating a VLAN,
there are 16-bits used to encode a VLAN ID and priority followed by
16-bits used to encode the actual Ethertype of the actual packet, which
can be any normal Ethertype. The VLAN Ethernet header instead looks
like:

```
+-------------+---------------+-----------+--------+-----------+------+
| 6-byte Dest | 6-byte Source | 2-byte    | 2-byte | 2-byte    | Data |
| MAC Address | Mac Address   | Ethertype | VLAN   | Ethertype |      |
|             |               | 0x8100    | id/pri |           |      |
+-------------+---------------+-----------+--------+-----------+------+
```

Packets that have this VLAN identifier are called tagged packets. This
tagging is standardized in `IEEE 802.1Q`.

Each VLAN identifier represents a unique segment. These can be used to
create independent, virtual networks that all share the same physical
network. Broadcast traffic on one VLAN does not reach another VLAN. This
also means that IP addresses can be reused in different VLANs
(though care still needs to be taken to ensure that there isn't overlap
if Layer 3 routing is involved).

VLANs can interact with the OS in two different ways:

1. The host OS can be aware of VLANs and explicitly add them to outgoing
packets and take them into account when receiving packets.

2. The host OS can be unaware of VLANs and a switch can add and remove
them.

Many switches have rules that say only specific VLANs are allowed to go
out on specific ports. If the switch encounters a packet with a tag that
is not in the list, then it will drop it. A switch may have additional
rules that state a packet that it encounters coming in on a given port
should be rewritten to include a VLAN tag before sending it out or that
when a specific VLAN is encountered, it should remove the tag before
delivering it to the port.

In Triton, both modes are often used. The admin network in Triton is
traditionally an `untagged` or `access-mode` network. Here the OS sends
and receives packets without a VLAN tag; however, the switch is
transparently adding and removing the tags as packets traverse the
network.

Pretty much every other network in Triton is generally a VLAN tagged
network. This means that all packets generated by the network must have
the correct VLAN tag. The VLAN tag is specified in a NAPI network and is
stored in the VM payload. When a VNIC is created, the `-v` option is
used to specify a VLAN tag that indicates what VLAN packets should be
tagged with and received on.

### KVM

All of our KVM guests today operate in a mode similar to the access mode
described above. While the underlying VNIC that a KVM guest can use may
be tagged with a VLAN and thus its packets rewritten by the illumos
networking stack, the guest cannot see any VLANs. In addition, if it
tries to send traffic tagged with a VLAN, it'll end up being dropped.

## Missing and Desired Functionality

This section goes over what functionality that exists in the stack that
cannot target VLANs and some of the additional follow on effects of
this that we would like to implement, but have not.

### GLDv3 Ring Polling on VLANs

The MAC driver (aka GLDv3) allows polling on rings that are fully
classified. The polling on a ring is important because of the current
design of MAC. MAC has an inherent high watermark for incoming packets.
If it exceeds that number of outstanding packets on a per-ring basis, it
will transition to polling mode. However, if it cannot transition to
polling mode, then it will drop packets.

This ends up creating an artificial limiter on performance of the
system as we end up dealing with dropped packets, which leads to
retransmits, etc. While, device that have VLANs associated with them may
have a group assigned to them (granting one or more rings), which helps
by providing dedicated resources, MAC does not enable polling.

MAC refuses to enable polling on rings with VLANs associated with them
because it cannot guarantee that the ring is fully filtered. However,
hardware does have the ability to filter on VLANs and filter them to
specific rings. We should explore this functionality and add support for
it to a number of drivers in the GLDv3.

Many of the devices supported by the GLDv3 support this functionality. A
summary of their functionality will be summarized and provided later in
this document in the section `Modern Hardware Capabilities`.

#### Associating additional VLANs with a VNIC

Another nice feature would be able to assign multiple VLANs to a given
VNIC. While it is tempting to say that we should just use multiple
logical devices with dladm create-vlan and more, this has a negative,
particularly on virtualization. In the case of virtualization, every
logical device that we have to listen on in the guest becomes something
that we have to pass through to the guest.

In this case, we may want to add something like the secondary-macs
property, but with VLANs.

One interesting question that this all rises is should we instead of
being just MAC specific, actually do something where we can program and
specify relationships between a VLAN and a MAC address? This would let
us say mac-a, vlan-a and mac-b, vlan-b can go to the same ring.

### Explicit VLAN antispoofing rules

One thing that'd be good to have on the sending side is an explicit set
of VLAN antispoofing rules and the ability to potentially allow
additional VLANs that one can send from. This may want to be phrased as
specific VLANs or as MAC, VLAN tuples. While there is some amount of
logic for checking this in MAC today, it isn't quite as strong as the
other antispoofing options that we have today.

### MAC DLS Bypass and Software Rings

Another useful feature of MAC right now is called `DLS Bypass`. The DLS
bypass basically allows all of DLS to be skipped and have frames sent
directly to ip_input(). This is generally only enabled for IPv4 TCP and
UDP rings when VLANs are not on the scene. This just adds another
unnecessary cost for using VLANs.

Most of the time this comes from us enabling the poll capability. For
example, see the following stack trace:

```
mac`mac_soft_ring_dls_bypass()
mac`mac_client_poll_enable+0x56(ffffff03d380f038)
dld`dld_capab_poll_enable+0x9b(ffffff03d95f4e48, ffffff000f352a00)
dld`dld_capab_poll+0x45(ffffff03d95f4e48, ffffff000f352a00, 1)
dld`dld_capab+0xa0(ffffff03d95f4e48, 2, ffffff000f352a00, 1)
ip`ill_capability_poll_enable+0x75(ffffff03d6613aa8)
ip`ill_capability_dld_enable+0x68(ffffff03d6613aa8)
ip`ill_capability_dld_ack+0xed(ffffff03d6613aa8, ffffff03d0bf0280, 
ffffff03d0c42260)
ip`ill_capability_dispatch+0xb5(ffffff03d6613aa8, ffffff03d0bf0280, 
ffffff03d0c42260)
ip`ill_capability_ack_thr+0xda(ffffff03d0bf0280)
taskq_d_thread+0xb7(ffffff03cff629d8)
thread_start+8()
```

One complication with this is the fact that we may need to be able to
listen on all VLANs on a given MAC. The problem is that someone can bind
to the VLAN Ethertype, at which point it needs to be able to manage and
handle receiving everything, unlike the filtering.

However, this is a rather *uncommon* operation. Therefore, it's not
unreasonable to try and do something such that if this happens we end up
going to a slow path. It may also be possible that we can rig this up
with most drivers such that it'll still end up being accepted in the
general ring rather than the specific one. So, we'll need to figure that
out, but it shouldn't be too bad. One way that we may end up being able
to do this is to basically force the underlying datalink to be
promiscuous so that way we don't have to interfere with the normal data
path and treat this as a variant to someone running snoop or other
operations.

#### Software Rings

Software rings in MAC are a means of fanning out the different physical
rings into different buckets and queues that can be processed in
parallel in the system. Today we bucket things into three categories:

* TCP / IPv4
* UDP / IPv4
* Everything else

In general, we should look, especially in the context of the above logic
to figure out if we can always decode the first level of VLAN tag and
share the existing TCP/UDP buckets. These buckets are tied directly into
what the clients are polling on in the above section. This
ring-classification is also a part of the DLS bypass operation.


All in all, both of these should be important and useful. This really
ties into GLDv3 polling on rings and how we end up really driving
packets.

## Modern Hardware Capabilities

There are a couple of different capabilities that we care about
regarding VLANs from hardware. We're mentioning all of these
capabilities, beyond those we're immediately interested in at Joyent to
make sure that we're properly designing changes. Today most hardware
offers:

  * Filtering traffic to a specific ring
  * Stripping the VLAN tag out of received packets
  * Inserting a VLAN tag into transmitted packets

Based on a brief survey, we know that newer Intel NICs support all of
these behavior in the 10+ Gb form factors. Only the I350 supports the
VLAN filters in this mode.

These filters often operate in one of two different ways to determine
whether or not a given packet should be sent to that specific group:

* They pass one filter and then another filter
* They match a specific tuple

Consider hardware like that supported by the `ixgbe` driver. It has a
separate set of filters for MAC addresses and then a separate set of
filters for VLANs. For a packet to enter a given ring, it must match any
of the MAC filters and then must match any of the VLAN filters. This
could be described roughly in the following pseudocode:

```
for each packet p:
    for each MAC filter m:
        if m matches p's mac:
            for each VLAN filter v:
                if v matches p's vlan:
                    accept p for group 
```

Basically each different kind of filter is treated as an AND and then
it's an OR inside of a filter.

Importantly this is distinct from the tuple-matching kinds of filters.
With these, your first filter is basically matching a specific tuple. So
say the filter provided a tuple based on (mac, vlan), this would look
like:

```
for each packet p:
    for each filter f:
        if f.mac matches p's mac and f.vlan matches p's vlan:
            accept p for group

```

This has ramifications for when we design kernel APIs. We'll need to be
very clear when we're ORing together and when we're ANDing things
together. It's important to be aware of these diverse types as we
evaluate hardware.

The hardware strategies that we need to consider 

| Driver | Ring Filtering | Filter Type | Tagging | Stripping | Notes |
| ------ | -------------- | ----------- | ------- | --------- | ----- |
| Broadcom NetXtreme-C/-E | yes+ |  Tuple+ | yes+ | yes+ | bnxt driver on Linux and FreeBSD |
| bnxe | yes | yes* | yes* | yes* | - |
| cxgbe | yes | Unknown | yes* | yes* | - |
| ixgbe | yes | Separate filters | yes, per packet | yes, per queue | also has global filters |
| igb/e1000g | no | N/A | yes, per packet | yes, per port | Filtering support is available on the I350, but not other models |
| i40e | yes | Both | yes, per packet | yes, per group (VSI) | - |
| QLogic 45000 series | yes | Both | yes, per packet | yes, per group | qede driver on Linux |
| Mellanox Connect-X4 | yes | Unknown | yes* | yes* | Likely applies to other gen products |

A '*' character indicates that we do not know for certain from the
documentation what the granularity of support is. A '+' character
indicates that we believe there is support based on information from
other device drivers; however, we do not have documentation to confirm
that.

While we're thinking about this on a purely per-VLAN basis, we also want
to think about this in terms of tuples that we may want to apply for a
given filter.

## New Interfaces

### GLDv3 Interface Changes

We'd like to stabilize the interfaces for the GLDv3 rings interfaces.
What we have today is mostly good. There are two major things that we
want to make sure are in place versus what exists at this moment:

#### Structure Extensibility

We'd like to make sure that the structures that we're passing in as
capabilities have some amount of extensibility. We'll need to explore
this and come up with a concrete proposal. This may be a matter of
adding both a version and flags fields to the start of the structures.


#### MAC and VLAN Filtering

We'd like to make sure that we had some kind of VLAN filtering that we
can add to the group API. Today, the current functions for MAC filters
look like:

```
typedef int (*mac_add_mac_addr_t)(void *driver, const uint8_t *mac)
typedef int (*mac_rem_mac_addr_t)(void *driver, const uint8_t *mac)
```

Earlier we talked about the different ways of specifying filters. Over
time, I suspect we're going to want more and more advanced filters;
however, it's important to note the tie between MAC and VLAN pairs. To
that end, I think the following function signatures should be added 

```
typedef int (*mac_add_mac_addr_t)(void *driver, const uint8_t *mac,
    uint_t flags)
typedef int (*mac_rem_mac_addr_t)(void *driver, const uint8_t *mac,
    uint_t flags)
typedef int (*mac_add_vlan_t)(void *driver, uint16_t vlan, uint_t flags)
typedef int (*mac_rem_vlan_t)(void *driver, uint16_t vlan, uint_t flags)
typedef int (*mac_add_mv_filter_t)(void *driver, const uint8_t *mac,
    uint16_t vlan, uint_t flags);
typedef int (*mac_rem_mv_filter_t)(void *driver, const uint8_t *mac,
    uint16_t vlan, uint_t flags);
```

The idea with these functions is that they allow us to add one of the
following three things:

1. A MAC-only filter that should be logically ORed with all the other
MAC filters. 

2. A VLAN-only filter that should be logically ORed with all other VLAN
filters.

3. A MAC, VLAN match filter. This should be logically ORed with all
other MAC, VLAN match filters.

The driver will be able to indicate whether it supports MAC, VLAN, or
MAC/VLAN tuple filters. If the driver supports more than one of the
filter options, then the documentation will indicate that the driver
should logically and between the filters.

A driver should either support the separate filters or the tuple. We'll
make it an error when registering the capability if it supports both.

One other thing to point out is that we added a flags argument that will
likely be NULL by default. This is really to allow us to extend things
in the future if there are arguments we want to add, for example, like
tagging and stripping VLAN information.

The following structures below are slight modifications of the current
ones that represent what we'd like to move things towards. This will be
updated with manual pages at a later date.

```
typedef struct mac_capab_rings_s {
	uint_t			mr_version;
	uint_t			mr_flags;
	mac_ring_type_t		mr_type;
	mac_groupt_type_t	mr_group_type;
	uint_t			mr_rnum;
	uint_t			mr_gnum;
	mac_get_ring_t		mr_rget;
	mac_get_group_t		mr_gget;
	mac_group_add_ring_t	mr_gaddring;
	mac_group_remove_ring_t	mr_gremring;
} mac_capab_rings_t;

typedef struct mac_group_info_s {
	uint_t			mgi_version;
	uint_t			mgi_flags;
	mac_group_driver_t	mgi_driver;
	mac_group_start_t	mgi_start;
	mac_group_start_t	mgi_stop;
	uint_t			mgi_count;
	mac_intr_t		mgi_intr;
	mac_add_mac_addr_t	mgi_addmac;	
	mac_rem_mac_addr_t	mgi_remmac;
	mac_add_vlan_t		mgi_addvlan;
	mac_rem_vlan_t		mgi_remvlan;
	mac_add_mv_filter_t	mgi_addmvf;
	mac_rem_mv_filter_t	mgi_remmvf;
} mac_group_info_t;

typedef struct mac_ring_info_s {
	uint_t			mri_version;
	uint_t			mri_flags;
	mac_ring_driver_t	mri_driver;
	mac_ring_start_t	mri_start;
	mac_ring_stop_t		mri_stop;
	mac_intr_t		mri_intr;
	union {
		mac_ring_send_t send;
		mac_ring_poll_t poll;
	} mrfunion;
	mac_ring_stat_t mri_stat;
} mac_ring_info_t;

#define	mri_tx		mrfunion.send
#define	mri_poll	mrfunion.poll
```
