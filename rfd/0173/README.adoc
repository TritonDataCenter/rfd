:author: Jason King
:email: jason.king@joyent.com
:state: predraft
:revremark: State: {state}

:showtitle:
:toc: left
:numbered:
:icons: font

////
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.

    Copyright 2019 Joyent, Inc
////

# RFD 173 KBMAPI and kbmd

## Introduction

(../0077/README.adoc)[RFD77] provides a high level overview of how cryptography
will be used to provide authentication for Triton services as well as
protecting the data residing on compute nodes.  This RFD is focused on the
details of the mechanisms that will be used to protect data at rest (also known
as EDAR--encrypted data at rest).  Specific functionality to provide secured
credential storage and authentication to instances (within kbmd, KBMAPI, as
well as other parts of the Triton stack) will be addressed in a future RFD.

[[overview]]
## Overview

To protect the contents of machines running Triton, we will utilize the
new encryption support in ZFS.  During the initial setup of an encryption
machine, a randomly-generated key is created and used to create the encrypted
zpool.  An unintialized PIV token (which must be present for the encrypted
setup to proceed) is also initialized during the setup process.  The PIV token
initialization performs several things:

 1. Several private keys are created by the token (which it will not reveal).
 2. A randomly generated secret PIN is set on the token.  This PIN is required
by the token before certain keys generated in step 1 can be used.

Information about each initialization PIV token (including the randomly
generated PIN) is saved in a trusted datacenter service (KBMAPI).  The zpool
key is then saved in an ECDH box.  This ECDH box requires the PIV token to
"open" the box and provide the key.  For the PIV token to open the ECDH box,
it must be given the PIN created during initalization.  A service on each
machine (kbmd) handles all the functions necessary for creating the encrypted
zpool, unlocking the encrypted zpool during boot, as well as recovering from
a lost of damanged PIV token.

[[glossary]]
## Glossary

This work introduces several new concepts and related vocabulary to the Triton
ecosystem.  To facilitate effective communication key terms are defined below.
Most of the terms have in-depth descriptions later in this document.

ebox:
  A container (i.e. data structure) for encrypted data and one or more
  sets of keys called _configurations_ that may be used to decrypt the encrypted
  data.

ebox template:
  An ebox with no encrypted data that is used to describe the configuration
  sections of an ebox.  A _recovery configuration_ is commonly held and/or
  distributed in an ebox template.

PIV token:
  A hardware device, such as a smart card or YubiKey, that meets the Personal
  Identity Verification standard set forth in [FIPS
  201](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.201-2.pdf).

primary token:
  The PIV token that is typically physically attached to a computer, such as by
  being inserted into a USB slot.  It is typically used in combination with a
  PIN or password to access secrets stored in one or more eboxes.

recovery:
  The process by which the protected content of an ebox is accessed using a
  _recovery configuration_.  This is a manual operation involving M challenges
  and responses as a result of a primary token failure.

recovery configuration:
  Two integers, M and N (M <= N), and a set of N public keys, M of which may be
  used to perform recovery in the even that a primary token is not available.
  Each public key corresponds to a _recovery PIV token_.

recovery PIV token:
  A PIV token that is used during recovery

recovery registry:
  If a machine has many eboxes on it, a recovery registry may be used to keep
  track of the location of all eboxes and to allow a single set of M
  challenges and responses to perform recovery on all eboxes.  A recovery
  registry is not present on a system that encrypts only one zpool (e.g. a
  system that has no zone soft tokens).

recovery token:
  A 32-byte random number used by a compute node to authenticate the compute
  node during recovery.  Do not confuse with _recovery PIV token_.

wrapping key:
  Each ZFS dataset is encrypted with one or more keys, depending on the size of
  the dataset.  Those keys are protected by a wrapping key, which is the key
  that is provided to `zfs load-key` and similar interfaces.  The wrapping key
  may be changed with `zfs change-key`.

YubiKey:
  A cryptographic token produced by [Yubico](https://www.yubico.com/).  This
  document is only concerned with those that implement the PIV standard and as
  such are considered _PIV tokens_.

[[kbmapi]]
## KBMAPI

As mentioned in <<overview>>, a trusted node service will be needed in a
datacenter to store the pins and recovery data for all of the tokens in the
datacenter.  This service is the Key Backup and Management API (KBMAPI).

KBMAPI will be a fairly simple and minimal REST service.  API endpoints
provide the means for adding new PIV tokens, removing PIV tokens,
recovering PIV tokens (i.e. replacing a PIV token), creating new recovery
tokens for a PIV token, and providing the PIN of a PIV token.

When a token is added, the KBMAPI service generates a recovery
token (a 32 byte blob of random data) that will be stored on the CN.  The
recovery token is limited to 32 bytes due to limitations in the Shamir secret
sharing code used during recovery.  As described in XXX, normally the PIV
token's 9E key is used to authenticate requests.  The recovery token acts as
a second authentication token used only when replacing a PIV token.

[[kbmapi-history]]
When tokens are deleted or reinitialized, the old token data should be kept in a
KBMAPI-maintained history.  This history maintains the token data for an
amount of time defined by the `KBMAPI_HISTORY_DURATION` SAPI variable.  The
default shall be 15 days.  The purpose is to provide a time-limited backup
against accidential token deletion.

### Attestation

:yubi-attest: https://developers.yubico.com/PIV/Introduction/PIV_attestation.html

Some tokens have extensions that allow for attestation -- that is a method
to show that a given key was created by the device and was not imported onto
the PIV token. For Yubikeys, this is done by creating a special x509 certificate
as detailed {yubi-attest}[here].

If an operator wishes to require attestation, they must set the
`KBMAPI_REQUIRE_ATTESTATION` SAPI parameter to `true`.  In addition, the
`KBMAPI_ATTESTATION_CA` SAPI parameter must be set to the CA certificate
used for attestation.

Additionally, an operator may wish to limit the tokens that are allowed to
be used with KBMAPI to a known set of tokens.  To do so, an operator
sets the SAPI parameter `KBMAPI_REQUIRE_TOKEN_PRELOAD` to `true`.  A command
line tool (working name `kbmctl`) is then used by the operator to load the
range of serial numbers into KBMAPI.  This is only supported for tokens that
support attestation (e.g. Yubikeys).  In other words, enabling
`KBMAPI_REQUIRE_TOKEN_PRELOAD` requires `KBMAPI_REQUIRE_ATTESTATION` to also
be enabled (but not necessarily vice versa).

It should be noted that since both the attestation and device serial numbers
are non-standard PIV extensions.  As such, support for either feature will
require kbmd / piv-tool and potentially kbmapi to support a particular device's
implementation.  Similarly, enabling the feature requires the use of PIV tokens
that implement the corresponding feature (attestation or a static serial number).
The initial scope will only include support for Yubikey attestation and serial
numbers.

In both cases, enforcement of the policy occurs during the provisioning
process (i.e. at the time of a CreateToken call).  Changes to either policy
do _not_ affect existing tokens in KBMAPI.

### PIV Token object

The PIV token data is stored persistently by the KBMAPI service. A moray bucket
is used for this purpose. The JSON config of the bucket is:

[source,json]
----
{
    "desc": "token data",
    "name": "tokens",
    "schema": {
        "index": {
            "guid": { "type": "string", "unique": true },
            "cn_uuid": { "type": "uuid", "unique": true }
        }
    }
}
----

The PIV token object itself is represented using JSON similar to:

[source,json]
----
{
    "model": "Yubico Yubikey 4",
    "serial": 5213681,
    "cn_uuid": "15966912-8fad-41cd-bd82-abe6468354b5",
    "guid": "97496DD1C8F053DE7450CD854D9C95B4",
    "pin": "123456",
    "recovery_tokens": [{
        "created": 123456789,
        "token": "jmzbhT2PXczgber9jyOSApRP337gkshM7EqK5gOhAcg="
    }, {
        "created": 2233445566,
        "token": "QmUgc3VyZSB0byBkcmluayB5b3VyIG92YWx0aW5l"
    }]
    "pubkeys": {
       "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
    },
    "attestation": {
       "9e": "-----BEGIN CERTIFICATE-----....",
       "9d": "-----BEGIN CERTIFICATE-----....",
       "9a": "-----BEGIN CERTIFICATE-----....."
    }
}
----

[options="header"]
|===

| Field | Required | Description

| model
| No
| The model of the token.

| serial
| No
| The serial number of the token (if available).

| cn_uuid
| Yes
| The UUID of the compute node that contains this token

| guid
| Yes
| The GUID of the provisioned token.

| pin
| Yes
| The pin of the provisioned token.

| recovery_tokens
| Yes
| An array of recovery tokens. Used as an alternate authentication key when
replacing a PIV token on a machine (usually due to loss or damange of the
original PIV token). They also serve as proof to KBMAPI that a recovery
operation was performed. When the recovery configuration is updated, a new
recovery token is generated and added to the list. A history of previous
tokens is kept to allow for propagation delays of new recovery configurations.

| pubkeys
| Yes
| A JSON object containing the _public_ keys of the token

| pubkeys.9a
| Yes
| The public key used for authentication after the token has been unlocked.

| pubkeys.9d
| Yes
| The public key used for encryption after the token has been unlocked.

| pubkeys.9e
| Yes
| The public key used for authenticating the token itself without a pin (e.g.
used when requesting the pin of a token).

| attestation
| No
| The attestation certificates for the corresponding pubkeys.

|===

Note that when provisioning a token, if any of the optional fields are known,
(e.g. `attestation` or `serial`) they should be supplied during provisioning.

### Token History

As a failsafe measure, when a token is deleted, the entry from the token
bucket is saved into a history bucket.  This bucket retains up to
`KBMAPI_HISTORY_DURATION` days of token data (see <<kbmapi-history>>).

The history bucket looks very similar to the token bucket:

[source,json]
----
{
    "desc": "token history",
    "name": "token_history",
    "schema": {
        "index": {
            "guid": { "type": "string" },
            "cn_uuid": { "type": "uuid" },
            "active_range": { "type": "daterange" }
        }
    }
}
----

The major difference is that the index fields are not unique as well as the
`active_range` index.  An accidentially deleted token that's restored might end
up with multiple history entries, and a CN which has had a token replacement
will also have multiple history entries.

The moray entry in the history bucket also looks similar, but not quite the
same as the token bucket:

[source,json]
----
{
    "active_range": "[2019-01-01 00:00:00, 2019-03-01 05:06:07]",
    "model": "Yubico Yubikey 4",
    "serial": 5213681,
    "cn_uuid": "15966912-8fad-41cd-bd82-abe6468354b5",
    "guid": "97496DD1C8F053DE7450CD854D9C95B4",
    "pin": "123456",
    "recovery_token": "jmzbhT2PXczgber9jyOSApRP337gkshM7EqK5gOhAcg=",
    "pubkeys": {
       "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
    },
    "attestation": {
       "9e": "-----BEGIN CERTIFICATE-----....",
       "9d": "-----BEGIN CERTIFICATE-----....",
       "9a": "-----BEGIN CERTIFICATE-----....."
    },
    "comment": ""
}
----

The major difference is the addition of the `active_range` property as well as
the `comment` property. The `active_range` property represents the (inclusive)
start and end dates that the provisioned token was in use.

It's permitted that the same provisioned token might have multiple entries in
the history table.  An example would be a token accidentially deleted and
restored would have an entry for the deletion, and then a second entry when
the token is retired (or reprovisioned).

The `comment` field is an optional field that contains free form text.  It is
intended to note the reason for the deletion.

To protect the token data in Moray, we will rely on the headnode disk
encryption.

**QUESTION**: Even though the HN token will not use the GetTokenPin
API call to obtain its pin, should we still go ahead and store the data for
the HN token in KBMAPI?  We cannot do it when we initialize the HN PIV token
because we are running the HN setup (this there is no KBMAPI up and running),
and we must use a different method to provide the PIN for a PIV token on a
headnode.

### Preloading Tokens

To support an operator preloading unprovisioned tokens, we track ranges of
serial numbers that are allowed to be provisioned.  We use a separate
moray bucket for tracking these ranges of serial numbers:

[source,json]
----
{
    "desc": "token serials",
    "name": "token_serial",
    "schema": {
        "index": {
            "ca_dn": { "type": "string" },
            "serial_range": { "type": "numrange" }
        }
    }
}
----

The entries look similar to:

[source,json]
----
{
    "serial_range": "[111111, 123456]",
    "allow": true,
    "ca_dn": "cn=my manf authority",
    "comment": "A useful comment here"
}
----

[options="header"]
|===

| Field | Description

| serial_range
| An range of serial numbers.  This range is inclusive.

| allow
| Set to true if this range is allowed, or false is this range is blacklisted.

| ca_dn
| The distinguished name (DN) of the attestation CA for this token.  Used to
disambiguate any potential duplicate serial numbers between vendors.

| comment
| An operator supplied free form comment

|===

The `kbmctl` command is used to manage this data.

### Audit Trail

Given the critical nature of the token data, we want to provide an audit
trail of activity.  While there is discussion of creating an AuditAPI at
some point in the future, it currently does not look like it would be available
to meet the current deadlines.  Once available, we should look at the effort
to migrate this functionality to AuditAPI.

In the meantime, we will provide the option of uploading the KBMAPI logs to
a Manta installation using hermes or possibly the new log archiver service
described in (../0163/README.md)[RFD163].

### Responses

All response objects are `application/json` encoded HTTP bodies.  In addition,
all responses will have the following headers:

[options="header"]
|===

| Header | Description

| Date   | When the response wqas send (RFC 1123 format)

| Api-Version | The exact version of the KBMAPI server that processed the request

| Request-Id | A unique id for this request.

|===

If the response contains content, the following additional headers will be
present:

[options="header"]
|===

| Header         | Description

| Content-Length | How much content, in bytes

| Content-Type
| The format of the response (currently always `application/json`)

| Content-MD5    | An MD5 checksum of the response

|===

### HTTP Status Codes

KBMAPI returns one of the following codes on an error:

[options="header"]
|===

| Code | Description | Details

| 401
| Unauthorized
| Either no Authorization header was send, or the credentials used were invalid

| 405
| Method Not Allowed
| Method not supported for the given resource

| 409
| Conflict
| A parameter was missing or invalid

| 500
| Internal Error
| An unexpected error occurred

|===

If an error occurs, KBMAPI will return a standard JSON error response object
in the body of the response:

[source,json]
----
{
    "code": "CODE",
    "message": "human readable string"
}
----

Where `code` is one of:

[options="header"]
|===

| Code | Description

| BadRequest
| Bad HTTP was sent

| InternalError
| Something went wrong in KBMAPI

| InvalidArgument
| Bad arguments or a bad value for an argument

| InvalidCredentials
| Authentication failed

| InvalidHeader
| A bad HTTP header was sent

| InvalidVersion
| A bad `Api-Version` string was sent

| MissingParameter
| A required parameter was missing

| ResourceNotFound
| The resource was not found

| UnknownError
| Something completely unexpected happened

|===

## KBMAPI Endpoints

These are the proposed endpoints to meet the above requrements.  They largely
document the behavior of the existing KBMAPI prototype (though in a few places
describe intended behavior not yet present in the prototype).

In each case, each request should include an `Accept-Version` header indicating
the version of the API being requested.  The initial value defined here shall
be '1.0'.

XXX: This is largely based on the behavior of CloudAPI.  Check what the
behavior of CloudAPI is if no version is supplied.

#### CreateToken (POST /pivtokens)

Add a new initialized PIV token.  Included in the request should be an
`Authorization` header with a method of 'Signature' with the date header
signed using the token's `9e` key.  The payload is a JSON object with the
following fields:

[options="header"]
|===

| Field | Required | Description

| guid
| Yes
| The GUID of the provisioned token

| cn_uuid
| Yes
| The UUID if the CN that contains this token

| pin
| Yes
| The pin for the token generated during provisioning

| model
| No
| The model of the token (if known)

| serial
| No
| The serial number of the token (if known)

| pubkeys
| Yes
| The public keys of the token generated during provisioning

| pubkeys.9a
| Yes
| The `9a` public key of the token

| pubkeys.9d
| Yes
| The `9d` public key of the token

| pubkeys.9e
| Yes
| The `9e` public key of the token

| attestation
| No
| The attestation certificates corresponding to the `9a`, `9d`, and `9e`
public keys.

|===

Note: for the optional fields, they should be supplied with the request when
known.  Unfortunately, there is no simple way to enforce this optionality on
the server side, so we must depend on the CN to supply the optional data
when appropriate.

If the signature check fails, a 401 Unauthorized error + NotAuthorized code
is returned.

If any of the required fields are missing, a 409 Conflict + InvalidArgument
error is returned.

If the `guid` or `cn_uuid` fields contain a value already in use in the
`tokens` bucket, a new entry is _not_ created.  Instead, the `9e` public key
from the request is compared to the `9e` key in the stored token data.  If
the keys match, and the signature check succeeds, then the `recovery_token`
value of the existing entry is returned and a 200 response is returned. This
allows the CN to retry a request in the event the response was lost.

If the `9e` key in the request does not match the `9e` key for the existing
token in the `tokens` bucket, but either (or both) the `guid` or `cn_uuid`
fields match an existing entry, a 409 Conflict + NotAuthorized error
is returned.  In such an instance, an operator must manually verify if the
information in the token bucket is out of date and manually delete it before
the token provisioning can proceed.

If an operator has hardware with duplicate UUIDs, they must contact
their hardware vendor to resolve the situation prior to attempting to provision
the PIV token on the system with a duplicate UUID.  While we have seen such
instances in the past, they are now fairly rare.  Our past experience has
shown that attempting to work around this at the OS and Triton level is
complicated and prone to breaking.  Given what is at stake in terms of the
data on the system, we feel it is an unacceptable risk to try to work around
such a situation (instead of having the hardware vendor resolve it).

If the request does not generate any of the above errors, the request is
If the attestation section is supplied, the attestation certs _must_ agree
with the pubkeys supplied in the request.  If they do not agree, or if
`KBMAPI_ATTESTATION_REQUIRED` is true and no attestation certs are provided, a
409 Conflict + InvalidArgument error is returned.

If `KBMAPI_REQUIRE_TOKEN_PRELOAD` is `true`, the serial number of
the token as well as the attestation certificates of the token in question
must be present in the CreateToken request.  KBMAPI performs a search for
a range of allowed serial numbers in the `token_serial` bucket whose
attestation CA DN matches the attestation CA of the token in the request.
If the serial number is not part of an allowed range, a
409 Conflict + InvalidArgument error is returned.

In addition, a recovery key is generated by KBMAPI and stored as part of the
token object.  This should be a random string of bytes generated by a random
number generator suitable for cryptographic purposes.

Once the entry is updated or created in moray, a successful response is
returned (201) and the generated recovery token is included in the response.

Example request (with attestation)

----
POST /pivtokens
Host: kbmapi.mytriton.example.com
Date: Thu, 13 Feb 2019 20:01:02 GMT
Authorization: Signature <Base64(rsa(sha256($Date)))>
Accept-Version: ~1
Accept: application/json

{
    "model": "Yubico Yubikey 4",
    "serial": 5213681,
    "cn_uuid": "15966912-8fad-41cd-bd82-abe6468354b5",
    "guid": "97496DD1C8F053DE7450CD854D9C95B4",
    "pin": "123456",
    "pubkeys": {
       "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
    },
    "attestation": {
       "9e": "-----BEGIN CERTIFICATE-----....",
       "9d": "-----BEGIN CERTIFICATE-----....",
       "9a": "-----BEGIN CERTIFICATE-----....."
    }
}
----

An example response might look like:

----
HTTP/1.1 201 Created
Location: /pivtokens/97496DD1C8F053DE7450CD854D9C95B4
Content-Type: application/json
Content-Length: 12345
Content-MD5: s5ROP0dBDWlf5X1drujDvg==
Date: Fri, 15 Feb 2019 12:34:56 GMT
Server: Joyent KBMAPI 1.0
Api-Version: 1.0
Request-Id: b4dd3618-78c2-4cf5-a20c-b822f6cd5fb2
Response-Time: 42

{
    "recovery_token": "jmzbhT2PXczgber9jyOSApRP337gkshM7EqK5gOhAcg="
}
----

### UpdateToken (PUT /pivtokens/:guid)

Update the current fields of a token.  Currently, the only field that can be
altered is the `cn_uuid` field (e.g. during a chassis swap).  If the new
`cn_uuid` field is already associated with an assigned token, or if any of
the remaining fields differ, the update fails.

This request is authenticated by signing the Date header with the token's 9e
key (same as CreateToken).  This however does not return the recovery token
in it's response.

Example request:

----
PUT /pivtokens/97496DD1C8F053DE7450CD854D9C95B4
Host: kbmapi.mytriton.example.com
Date: Thu, 13 Feb 2019 20:01:02 GMT
Authorization: Signature <Base64(rsa(sha256($Date)))>
Accept-Version: ~1
Accept: application/json

{
    "model": "Yubico Yubikey 4",
    "serial": 5213681,
    "cn_uuid": "99556402-3daf-cda2-ca0c-f93e48f4c5ad",
    "guid": "97496DD1C8F053DE7450CD854D9C95B4",
    "pin": "123456",
    "pubkeys": {
       "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
    },
    "attestation": {
       "9e": "-----BEGIN CERTIFICATE-----....",
       "9d": "-----BEGIN CERTIFICATE-----....",
       "9a": "-----BEGIN CERTIFICATE-----....."
    }
}
----

Example response:

----
HTTP/1.1 200 OK
Location: /pivtokens/97496DD1C8F053DE7450CD854D9C95B4
Content-Type: application/json
Content-Length: 1122
Content-MD5: s5ROP0dBDWlf5X1drujDvg==
Date: Sun, 17 Feb 2019 10:27:43 GMT
Server: Joyent KBMAPI 1.0
Api-Version: 1.0
Request-Id: 7e2562ba-731b-c91b-d7c6-90f2fd2d36a0
Response-Time: 23

----

### RecoverToken (POST /pivtokens/:guid/recover)

When a token is no longer available (lost, damaged, accidentially reinitialized,
etc.), a recovery must be performed.  This allows a new token to replace the
unavailable token.  When a recovery is required, an operator initiates the
recovery process on the CN.  This recovery process on the CN will decrypt the
current `recovery_token` value for the lost token that was created during the
lost token's CreateToken request or a subsequent `CreateRecoveryToken` request.
For some TBD amount of time, earlier `recovery_token` values may also be allowed
to account for propagation delays when updating recovery configurations using
the gossip protocol. KBMAPI may also optionally periodically purge members of
a token's `recovery_tokens` array that are sufficiently old to no longer
be considered valid (even when accounting for propagation delays).

The CN submits a RecoverToken request to replace the unavailable token
with a new token.  The `:guid` parameter is the guid of the unavailable token.
The data included in the request is identical to that of a CreateToken request.
The major difference is that instead of using a token's 9e key to sign the date
field, the decrypted `recovery_token` value is used as the signing key (in
conjunction with some HMAC mechanism).

If the request fails the authentication requests, a 401 Unauthorized error
is returned.

If all the checks succeed, the information from the old token (`:guid`) is
moved to a history entry for that token.

An example request:

----
POST /pivtokens/97496DD1C8F053DE7450CD854D9C95B4/recover
Host: kbmapi.mytriton.example.com
Date: Thu, 13 Feb 2019 20:01:02 GMT
Authorization: Signature <Base64(rsa(sha256($Date)))>
Accept-Version: ~1
Accept: application/json

{
    "model": "Yubico Yubikey 4",
    "serial": 6324923,
    "cn_uuid": "15966912-8fad-41cd-bd82-abe6468354b5",
    "guid": "75CA077A14C5E45037D7A0740D5602A5",
    "pin": "424242",
    "pubkeys": {
       "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
    },
    "attestation": {
       "9e": "-----BEGIN CERTIFICATE-----....",
       "9d": "-----BEGIN CERTIFICATE-----....",
       "9a": "-----BEGIN CERTIFICATE-----....."
    }
}
----

And an example response:

----
HTTP/1.1 201 Created
Location: /pivtokens/75CA077A14C5E45037D7A0740D5602A5
Content-Type: application/json
Content-Length: 12345
Content-MD5: s5ROP0dBDWlf5X1drujDvg==
Date: Fri, 15 Feb 2019 12:54:56 GMT
Server: Joyent KBMAPI 1.0
Api-Version: 1.0
Request-Id: 473bc7f4-05cf-4edb-9ef7-8b61cdd8e6b6
Response-Time: 42

{
    "recovery_token": "ShCopwm8QUWsujJQHV7igNxVaWx4ZzmU5SpQtaOC+TY="
}
----

Note that the location contains the guid of the _new_ token.

### CreateRecoveryToken (GET /pivtokens/:guid/recover)

Create a new recovery token for the given PIV token.  The request should be
authenticated by the PIV token.  When a new recovery configuration is propagated
to CNs via the gossip protocol, a new ebox is created which includes a new
recovery token.  The request _must_ be authenticated using the 9e key.  If
authentication fails, a 401 Unauthorized error + NotAuthorized code is returned.

Example request:

----
GET /pivtokens/75CA077A14C5E45037D7A0740D5602A5/recover
Host: kbmapi.mytriton.example.com
Date: Fri, 5 Jun 2019 11:24:00 GMT
Authorization: Signature <Base64(rsa(sha256($Date)))>
Accept-Version: ~1
Accept: application/json
----

Example reply:

----
HTTP/1.1 201 Created
Location: /pivtokens/75CA077A14C5E45037D7A0740D5602A5/recover
Content-Type: application/json
Content-Length: 12345
Content-MD5: s5RFP2dBDXlf5X1drujDvg==
Date: Fri, 5 Jun 2019 11:24:24 GMT
Server: Joyent KBMAPI 1.0
Api-Version: 1.0
Request-Id: bd73cff7-325f-64d8-cb0f-8c2ca8ecbd7d
Response-Time: 16

{
    "recovery_token": "QmUgc3VyZSB0byBkcmluayB5b3VyIG92YWx0aW5l"
}
----

XXX: Is 201 the best thing to return here?  Should we consider some mechanism
in the request/response to make this retry-able w/o generating and saving a new
token each time (to prevent a single recovery configuration update from
creating multiple recovery tokens due to network/retry issues).

#### ListTokens (GET /pivtokens)

Gets all provisioned pivtokens.  The main requirement here is no
sensitive information of a token is returned in the output.

Filtering by at least the `cn_uuid` as well as windowing functions should be
supported.

An example request:

----
GET /pivtokens
Host: kbmapi.mytriton.example.com
Date: Wed, 12 Feb 2019 02:04:45 GMT
Accept-Version: ~1
Accept: application/json
----

An example response:

----
HTTP/1.1 200 Ok
Location: /pivtokens
Content-Type: application/json
Content-Length: 11222333
Content-MD5: s5ROP0dBDWlf5X1drujDvg==
Date: Wed, 12 Feb 2019 02:04:45 GMT
Server: Joyent KBMAPI 1.0
Api-Version: 1.0
Request-Id: af32dafe-b9ed-c2c1-b5e5-f5fefc40aba4
Response-Time: 55

{
    [
        {
            "model": "Yubico Yubikey 4",
            "serial": 5213681,
            "cn_uuid": "15966912-8fad-41cd-bd82-abe6468354b5",
            "guid": "97496DD1C8F053DE7450CD854D9C95B4"
            "pubkeys": {
               "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
               "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
               "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
            }
        },
        {
            "model": "Yubico Yubikey 5",
            "serial": 12345123,
            "cn_uuid": "e9498ab2-d6d8-ca61-b908-fb9e2fea950a",
            "guid": "75CA077A14C5E45037D7A0740D5602A5",
            "pubkeys": {
               "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
               "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
               "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
            }
        },
        ....
    ]
}
----

### GetToken (GET /pivtokens/:guid)

Gets the public info for a specific token.  Only the public fields are
returned.

Example request:

----
GET /pivtokens/97496DD1C8F053DE7450CD854D9C95B4
Host: kbmapi.mytriton.example.com
Date: Wed, 12 Feb 2019 02:10:32 GMT
Accept-Version: ~1
Accept: application/json
----

Example response:

----
HTTP/1.1 200 Ok
Location: /pivtokens/97496DD1C8F053DE7450CD854D9C95B4
Content-Type: application/json
Content-Length: 12345
Content-MD5: s5REP1dBDWlf5X1drujDvg==
Date: Wed, 12 Feb 2019 02:10:35 GMT
Server: Joyent KBMAPI 1.0
Api-Version: 1.0
Request-Id: de02d045-f8df-cf51-c424-a21a7984555b
Response-Time: 55

{
   "model": "Yubico Yubikey 4",
   "serial": 5213681,
   "cn_uuid": "15966912-8fad-41cd-bd82-abe6468354b5",
   "guid": "97496DD1C8F053DE7450CD854D9C95B4"
   "pubkeys": {
      "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
      "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
      "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
   }
}
----

### GetTokenPin (GET /pivtokens/:guid/pin)

Like GetToken, except it also includes the `pin`.  The `recovery_token` field
is *not* returned.  This request must be authenticated using the 9E key of the
token specified by `:guid` to be successful.  An `Authorization` header should
be included in the request, the value being the signature of the `Date` header
(very similar to how CloudAPI authenticates users);

This call is used by the CN during boot to enable it to unlock the other
keys on the token.

An example request:

----
GET /pivtokens/97496DD1C8F053DE7450CD854D9C95B4/pin
Host: kbmapi.mytriton.example.com
Date: Wed, 12 Feb 2019 02:11:32 GMT
Accept-Version: ~1
Accept: application/json
Authorization: Signature <Base64(rsa(sha256($Date)))>
----

An example reply:

----
HTTP/1.1 200 OK
Location: /pivtokens/97496DD1C8F053DE7450CD854D9C95B4/pin
Content-Type: application/json
Content-Length: 2231
Date: Thu, 13 Feb 2019 02:11:33 GMT
Api-Version: 1.0
Request-Id: 57e46450-ab5c-6c7e-93a5-d4e85cd0d6ef
Response-Time: 1

{
    "model": "Yubico Yubikey 4",
    "serial": 5213681,
    "cn_uuid": "15966912-8fad-41cd-bd82-abe6468354b5",
    "guid": "97496DD1C8F053DE7450CD854D9C95B4",
    "pin": "123456",
    "pubkeys": {
       "9e": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9d": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA...",
       "9a": "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYA..."
    },
    "attestation": {
       "9e": "-----BEGIN CERTIFICATE-----....",
       "9d": "-----BEGIN CERTIFICATE-----....",
       "9a": "-----BEGIN CERTIFICATE-----....."
    }
}
----

### DeleteToken (DELETE /pivtokens/:guid)

Deletes information about a pivtoken.  This would be called during the
decommission process of a CN.  The request is authenticated using the 9e
key of the token.

Sample request:

----
DELETE /pivtokens/97496DD1C8F053DE7450CD854D9C95B4 HTTP/1.1
Host: kbmapi.mytriton.example.com
Accept: application/json
Authorization: Signature <Base64(rsa(sha256($Date)))>
Api-Version: ~1
Content-Length: 0
----

Sample response:

----
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, Api-Version, Response-Time
Access-Control-Allow-Methods: GET, HEAD, POST, DELETE
Access-Control-Expose-Headers: Api-Version, Request-Id, Response-Time
Connection: Keep-Alive
Date: Thu, 21 Feb 2019 11:26:19 GMT
Server: Joyent KBMAPI 1.0.0
Api-Version: 1.0.0
Request-Id: f36b8a41-5841-6c05-a116-b517bf23d4ab
Response-Time: 997
----

Note: alternatively, an operator can manually run kbmctl to delete an entry.

## kbmctl

This is a command line tool that exists in the KBMAPI zone used to manage
the KBMAPI data by an operator.  In earlier revisions, this was called
`kbmadm`, but that could cause confusion with kbmd's `kbmctl`, so a different
name was chosen.

### kbmctl add-serials

Usage: `kbmctl add-serials -d CA_dn start [end]`

Adds the range [`start`, `end`] (i.e. inclusive) that use `CA_dn` as their
attestation CA to the list of tokens that can be provisioned. If `end` is
omitted, the range is treated as [`start`, `start`] (i.e. a single entry).

### kbmctl delete-serials

Usage: `kbmctl delete-serials -d CA_dn start [end]`

Removes the serial number range [`start`, `end`] which use `CA_dn` as their
attestation CA to the list of tokens that can be provisioned.  If `end` is
omitted the range is treated as [`start`, `start`] (i.e. a single entry).

### kbmctl delete-token

Usage: `kbmctl delete-token guid`

Deletes the token with the given guid

### kbmctl restore

Usage: `kbmctl restore [-f] [-c cn_uuid] guid [timestamp]`

Restores the data for the token with the given uuid from the history table.
If multiple entries for the same GUID are present, `timestamp` must be
supplied to identify the entry to restore (the entry whose active range
contains timestamp is chosen).  Optionally, restore the token to the given
CN (if different from the history entry).

If the given CN already has a provisioned token assigned to it, this fails
unless the -f flag is provided.

### kbmctl history

Shows the history entries

**XXX**: Add more detail.

## kbmd

### Introduction

kbmd (read: kaboom-dee) has 3 big areas of responsibility:

Firstly, it's responsible for the "recovery" process -- when a server
has lost its primary Yubikey/PIV token, it is responsible for providing
the interface an administrator uses (either on the console or a pty) to
recover encryption keys, set up a new Yubikey, and get the system back
on track. Since this logically requires it to be able to set up new
Yubikeys from scratch, it's also involved in the initial setup process
to keep all the responsibility for that together.

Secondly, it's responsible for the "unlock" process at boot --
determining whether the primary Yubikey is available, getting the PIN
(from boot-time module or pool config for standalone, or spawning a
client to talk to KBMAPI), and if those fail, deciding whether to enter
"recovery".

Thirdly, it's responsible for everything during normal runtime that's
required to make those two processes work. This mostly means keeping
track of the encrypted data boxes on the machine and the "recovery
registry" (getting to that in a sec). It also means operating a door
server and accepting requests from a commandline admin tool, "kbmadm".

The name "kbmd" reflects this -- "Key Backup and Management Daemon".
(Definitely not a backronym so we can pronounce it "kaboom". Definitely
not.)

Encrypted boxes on the system fundamentally come in two forms -- there's
the boxes associated with the zpool (one set for the primary Yubikey and
one set for recovery), and then there are boxes for each of the keys
stored by the RFD77 soft-token (recall that the soft-token individually
encrypts its keys even when zpool encryption is enabled, as part of the
effort to make a "class break" that compromises all of the keys on the
system in one single operation, as difficult as possible).

The boxes themselves are stored as a zfs property (`rfd77:config`).  The
currently size limitations of zfs properties should allow for a single
property to store approximately 8 boxes worth of data.

The soft-token keys have to be boxed individually to the primary token
(so that the primary token can't unlock all of them in a single
operation), but they do not have to be boxed individually to the backup
keys. In fact, it would be pretty inconvenient if they were, because we
would have to do the challenge-response process at least N times for a
machine with N zones on it.

So instead, the soft-token keys' backup comes in the form of a single
large box (keyed only to the backup keys) which unlocks all of them.
Every time we need to add or remove something from that box, we have to
regenerate it from scratch using the individual boxes targetted to the
primary Yubikey. So we keep a plaintext record next to it of the
locations of all of the primary Yubikey boxes on disk. We call this
whole structure together the "recovery registry".

This implies that the storage of these keys is somewhat managed by the
system, and it is. When the soft-token wants to generate a new key, it
has to coordinate with kbmd (via its door) to let it know the correct
filesystem paths to find the primary boxes, and make sure the entries
are added to the recovery registry and everything there is dealt with.

Since this happens when a new zone is provisioned, and an attacker is
generally assumed to be able to provision things in the system, we don't
really want this to cause us to bring keys belonging to existing zones
into RAM in a predictable controllable fashion. So the recovery registry
is in fact split into two parts -- the "old generation" and "new
generation". When we add new keys we add them to the "new generation"
and regenerate that only. Then, every 6-12 hours or so (completely at
random) we combine the old and new generations together and regenerate
the whole thing. This avoids an attacker being able to control the
timing and nature of this operation easily (and it also means we don't
have to regenerate the whole registry every time we make a change -- we
basically bulk a bunch of changes up).

### Usage

kbmd is managed using the `kbmadm` command.  This communicates with kbmd
via a private channel (currently a door) to send requests and receive
responses.  The behavior and format of the data sent across the door between
kbmd and kbmadm is considered a private interface.  Mixing versions of kbmd
and kbmadm is explicitly not supported -- they should always be updated in
tandem.  Since initial delivery of both programs is targeted to be a part
of the platform image, this shouldn't impose any additional maintence burden.

`kbmadm create-zpool args...`

Creates an encrypted zpool.  `args` are the same arguments as `zpool create`.
This initializes an attached PIV token (must be present), registers the PIV
token with KBMAPI (receiving a recovery token in the process), creates a
random encryption key for the pool, creates an ebox with the zpool key and
recovery token (using the current recovery template for the recovery
configuration) and then runs `zpool create`.

`kbmadm unlock dataset`

Opens the ebox associated with the given dataset, loads the key for the dataset,
and if the dataset corresponds to the topmost dataset of a pool, mounts all
the normal datasets that are typically mounted during a `zpool import`.  If
the dataset is the top most dataset in a pool, and is the system zpool (as
denoted by the presence of /_pool_/.system_pool), the PIV token used to
unlock the dataset's ebox is designated as the system PIV token.

Note: we currently only create eboxes for the top most dataset in a pool, but
since it would actually be more work to restrict the unlock to a top-most
dataset, we leave the ability to unlock any dataset with an ebox for possible
future use.

`kbmadm recover`

Start a recovery of an ebox (see <<recovery>> below).

`kbmadm update-recovery`

Update the recovery configuration of an ebox.  This is currently for testing
purposes, but may be retained for use in standalone (non-Triton) installations.

[[recovery]]
### In depth: recovery

A recovery instance is created when another program running as root with
full privs connects to the kbmd door and sends a "begin recovery"
request (`kbmadm recover`). If kbmd decides it needs to initiate recovery on
the console (e.g. during boot), it forks a child to start kbmadm to do this and
places it on the console.

The "begin recovery" request is followed by a "conversation" similar to
a PAM conversation: kbmd gives the client some text and instructions on
what to ask the user and what options to allow them to reply with, the
client replies with the user's response, kbmd gives more questions to
ask the user etc.

At the end of the conversation, kbmd does not reply to the final
response until recovery is complete.

kbmd does the following before replying to the final response:

1. A new token value is added to the `rfd77:config` zfs property on the
   primary zpool (i.e. zones).
2. New managed box files with the GUID of the new token are created.
3. Remove the old primary token from the `rfd77:config` zfs property on the
   primary zpool.
4. Cleanup old managed box files: any box for a GUID not in `rfd77:config` or
   otherwise not known are deleted.

### In depth: boxes and eboxes

#### DH Box

As mentioned previously, a DH box is an encrypted container used to hold
a key.  The design is such that only the holder of the private key of the
box (which in our design is the PIV token) can decrypt and access the
contents of the box.  The box also includes some metadata to facilitate
their use.  The format of a box is illustrated by the following diagram:

....
+---------------+
| magic         | uint8 0xB0
|               | uint8 0xC5
+---------------+
| version       | uint8 (01)
+---------------+
|               |
| guid          | string
|               |
|               |               /+---------------+
+---------------+              / |               |
| slot          | uint8 (9D)  /  | type          | cstring
+---------------+------------+   |               | (ecdsa-sha2-nistp*)
|               |                +---------------+
| ephem pubkey  | string         | curve         | cstring
|               |                +---------------+
|               |                |               |
+---------------+------------+   | ecpoint       | string
|               |             \  |               | (0x04, ...)
| dest pubkey   | string       \ |               | uncompressed
|               |               \+---------------+
|               |
+---------------+
|               |
| cipher        | cstring (chacha20-poly1305)
|               |
+---------------+
|               |
| kdf           | cstring (sha512)
|               |
+---------------+
|               |
| iv            | string
|               |
|               |
+---------------+
|               |
| encdata       | string
|               |
|               |
+---------------+
....

The types of each field refer to the types used by SSH for parsing.

#### ebox (Version 1)

NOTE: RFD77 does not use version 1 eboxes.  However code was published
(earlier versions of pivy) that could use it.  The version is documented here
for historical purposes.

An ebox (enhanced box) can contain a box as described above, as well as one
or more recovery boxes.  If an ebox contains multiple recovery boxes, these
are the M pieces of an N of M threshold scheme (where N of M pieces are needed
to determine the key).

....
+---------------+
| magic         | uint8 (0xEB)
|               | uint8 (0x0C)
+---------------+
| version       | uint8 (01)
+---------------+
| type          | uint8
+---------------+
|               |
| cipher        | cstring
|               |
+---------------+
|               |
| iv            | string
|               |
+---------------+
|               |
| encdata       | string       /+---------------+
|               |             / | type          | uint8
+---------------+            /  +---------------+
| nconfigs      | uint8     /   | n             | uint8
+---------------+----------+    +---------------+
|               |               | m             | uint8
| config        |               +---------------+
|               |               |               |
+---------------+----------+    | part          |
|               |           \   |               |
| config...     |            \  +---------------+
|               |             \ | part...       |
+---------------+              \+---------------+
....

`nconfigs` determine the number of config structures are in the ebox (at least
1 is required).

For each config, `m` determines the number of parts present.  Each `part` is
a sequence of tag/value pairs terminated by a `EBOX_PART_END` tag.

Generic structure
....
+---------------+
| tag           | uint8
+---------------+
|               |
| value         |
|               |
+---------------+
| tag           | uint8
+---------------+
|               |
| value         |
|               |
+---------------+
| ...           |
+---------------+
| tag           | uint8 (EBOX_PART_END)
+---------------+
....

Public key
....
+---------------+
| tag           | uint8 (EBOX_PART_PUBKEY)
+---------------+
|               |
| pubkey        | stringb
|               |
+---------------+
....

Card Authentication Key (CAK)
....
+---------------+
| tag           | uint8 (EBOX_PART_CAK)
+---------------+
|               |
| cak           | stringb
|               |
+---------------+
....

Name
....
+---------------+
| tag           | uint8 (EBOX_PART_NAME)
+---------------+
|               |
| name          | cstring
|               |
+---------------+
....

GUID
....
+---------------+
| tag           | uint8 (EBOX_PART_GUID)
+---------------+
|               |
| guid          | string
|               |
+---------------+
....

BOX
....
+---------------+
| tag           | uint8 (EBOX_PART_BOX)
+---------------+
|               |
| box           | (see above definition)
|               |
+---------------+
....

#### ebox (Version 2)

Version 2 has a few changes (mostly surrounding the EBOX_PART_BOX config part)
that allow for a more compact representation, allow for more PIV tokens in
a recovery config to fix in a given size.

....
+---------------+
| magic         | uint8 (0xEB)
|               | uint8 (0x0C)
+---------------+
| version       | uint8 (02)
+---------------+
| type          | uint8 (02 = EBOX_KEY, 03 = EBOX_STREAM)
+---------------+
|               |
| cipher        | cstring
|               |
+---------------+
|               |
| iv            | string
|               |
+---------------+
|               |
| encdata       | string
|               |
+---------------+
| neeks         | uint8     /+--------+
+---------------+----------+ | tname  | cstring
|               |            +--------+
| eek...        |            |        |
|               |            | EC key | eckey8
+---------------+----------+ |        |
| nconfigs      | uint8     \+--------+
+---------------+
|               |
| config        |
|               |
+---------------+
|               |
| config...     |
|               |
+---------------+
....

`neeks` is the number of ephemeral keys
`eek` is an ephemeral key
`tname` is the curve name of the ephemeral key
`EC key` is the EC key

Note that `nconfig` must be > 0.

Each config block consists of:

....
+--------------+
| type         | uint8 (01 = EBOX_PRIMARY, 02 = EBOX_RECOVERY)
+--------------+
| n            | uint8
+--------------+
| m            | uint8
+--------------+
|              |
| part         |
|              |
+--------------+
|              |
| part...      |
|              |
+--------------+
....

For `EBOX_PRIMARY`, `n` must equal 1.

##### Part Generic structure

Each config part consists of a one octet tag followed by a value.  The size of
a part varies based on the tag.   Some tags (e.g. EBOX_PART_SLOT) have a fixed
size, while others may contain variable length data.  For tags that contain
variable length data, each one has their own way of determining the size of
the part.  Most of the libssh types (e.g. stringb) provide for this as
part of the type.

....
+---------------+
| tag           | uint8
+---------------+
|               |
| value         |
|               |
+---------------+
| tag           | uint8
+---------------+
|               |
| value         |
|               |
+---------------+
| ...           |
+---------------+
| tag           | uint8 (EBOX_PART_END)
+---------------+
....

Public key
....
+---------------+
| tag           | uint8 (EBOX_PART_PUBKEY)
+---------------+
|               |
| tname         | cstring
|               |
+---------------+
|               |
| EC key        | eckey8
|               |
+---------------+
....

Card Authentication Key (CAK)
....
+---------------+
| tag           | uint8 (EBOX_PART_CAK)
+---------------+
|               |
| cak           | stringb
|               |
+---------------+
....

Name
....
+---------------+
| tag           | uint8 (EBOX_PART_NAME)
+---------------+
|               |
| name          | cstring
|               |
+---------------+
....

GUID
....
+---------------+
| tag           | uint8 (EBOX_PART_GUID)
+---------------+
|               |
| guid          | string
|               |
+---------------+
....

BOX
....
+---------------+
| tag           | uint8 (EBOX_PART_BOX)
+---------------+
|               |
| cipher        | cstring (chacha20-poly1305)
|               |
+---------------+
|               |
| kdf           | cstring (sha512)
|               |
+---------------+
|               |
| nonce         | string8
|               |
+---------------+
|               |
| tname         | cstring
|               |
+---------------+
|               |
| EC Key        | eckey8
|               |
+---------------+
|               |
| IV            | string8
|               |
+---------------+
....

Note: the ephemeral key for the `EC key` is one of the `eek` values in the
ebox.  There is one ephemeral key per curve type.

SLOT
....
+---------------+
| tag           | uint8 (EBOX_PART_SLOT)
+---------------+
| slot          | uint8
+---------------+
....

#### ebox template

An ebox template is a special type of ebox.  It does not contain any
ephemeral keys or boxes.  It is used when constructing an ebox to describe
the config sections of an ebox.  Recovery configurations are represented as
ebox templates (which are then used when creating new eboxes) consisting of
EBOX_RECOVERY configs.

....
+---------------+
| magic         | uint8 (0xEB)
|               | uint8 (0x0C)
+---------------+
| version       | uint8 (02)
+---------------+
| type          | uint8 (01 = EBOX_TEMPLATE)
+---------------+
| nconfigs      | uint8
+---------------+
|               |
| config        |
|               |
+---------------+
|               |
| config...     |
|               |
+---------------+
....

The config blocks are the same as in the other types of eboxes.  The one
exception is that EBOX_PART_BOX parts are not allowed in templates.
